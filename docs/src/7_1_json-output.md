# JSON Output Format

This chapter explains the JSON structure generated by the Mortar compiler.

## Overall Structure

The compiled JSON file has three main top-level fields:

```json
{
  "nodes": {
    // Node definitions
  },
  "functions": [
    // Function declarations
  ],
  "metadata": {
    // Compiler version and other metadata
  }
}
```

## nodes Field

`nodes` is an object (dictionary) where keys are node names and values are the corresponding node data objects.

### Node Structure

Each node object contains the following fields:

```json
{
  "nodes": {
    "NodeName": {
      "texts": [...],          // An array of text blocks
      "choices": [...],        // An array of choice options (optional)
      "next_node": "NextNode"  // The default next node to jump to (optional)
    }
  }
}
```

## texts Field

`texts` is an array containing all text blocks within a node.

### Field Description

Each text block is an object with these fields:

- `content` (String): The actual text content.
- `interpolated` (Boolean): `true` if the text contains string interpolation (e.g., `$"Hello, {get_name()}"`).
- `events` (Array): An array of event groups bound to this text.

### Examples

#### Simple Text
```json
{
  "content": "Hello, world!",
  "interpolated": false,
  "events": []
}
```

#### Text with Interpolation
Note: The actual replacement of `{...}` placeholders is handled by the game engine at runtime.
```json
{
  "content": "Hello, {get_player_name()}!",
  "interpolated": true,
  "events": []
}
```

#### Text with Events
```json
{
  "content": "Thunder rumbles!",
  "interpolated": false,
  "events": [
    {
      "index": 0,
      "calls": [
        {
          "function": "shake_screen",
          "args": []
        }
      ]
    },
    {
      "index": 8,
      "calls": [
        {
          "function": "play_sound",
          "args": ["thunder.wav"]
        }
      ]
    }
  ]
}
```

## events Field Details

Each object in the `events` array is an **event group** that contains:

- `index` (Number): The trigger position (can be an integer or a decimal).
- `calls` (Array): A list of function calls to be executed at that index.

```json
{
  "index": 0.0,
  "calls": [
    {
      "function": "function_name",
      "args": [ ... ]
    }
  ]
}
```

### Multiple Events at the Same Position
If multiple functions are called at the same index, they are added to the same `calls` array.
```json
"events": [
  {
    "index": 0,
    "calls": [
      { "function": "effect_a", "args": [] },
      { "function": "effect_b", "args": [] }
    ]
  }
]
```
The game engine should execute these calls in the order they appear in the array.

### Decimal Indices
```json
"events": [
  {
    "index": 0.0,
    "calls": [{ "function": "start_voice", "args": ["dialogue.wav"] }]
  },
  {
    "index": 1.5,
    "calls": [{ "function": "blink_eyes", "args": [] }]
  }
]
```
This is particularly useful for synchronizing events with audio or video timelines.

### Function Arguments
Arguments in the `args` array can be of any standard JSON type:
- **String**: `"hello.wav"`, `"red"`
- **Number**: `42`, `3.14`
- **Boolean**: `true`, `false`

```json
"events": [
  {
    "index": 0,
    "calls": [
        {
            "function": "spawn_enemy",
            "args": ["Goblin", 100, 200, true]
        }
    ]
  }
]
```

## choices Field

`choices` is an array of choice objects. Each object can represent a simple choice, a conditional choice, or a nested choice menu.

### Simple Choice
```json
"choices": [
  {
    "text": "Go to the forest",
    "target": "ForestScene"
  },
  {
    "text": "Go to the town",
    "target": "TownScene"
  }
]
```

### Conditional Choice
The `condition` field contains the name of a boolean function to be called by the game engine. The option should only be displayed if the function returns `true`.
```json
"choices": [
  {
    "text": "Use magic",
    "target": "MagicPath",
    "condition": "can_use_magic"
  },
  {
    "text": "Use physical attack",
    "target": "PhysicalPath"
  }
]
```

### Nested Choices
A choice object can contain a `nested` field, which is another array of choice objects. This represents a sub-menu.
```json
"choices": [
  {
    "text": "Eat something",
    "nested": [
      {
        "text": "Apple",
        "target": "EatApple"
      },
      {
        "text": "Bread",
        "target": "EatBread"
      }
    ]
  },
  {
    "text": "Leave",
    "target": "Leave"
  }
]
```
When the player selects "Eat something", the game should display the choices within the `nested` array.

### Special Targets
The `target` field can contain special keywords:
- `"return"`: Signals the end of the current node's execution.
- `"break"`: Signals to exit the current choice block and continue executing content within the same node.

```json
"choices": [
  {
    "text": "Exit Dialogue",
    "target": "return"
  },
  {
    "text": "Never mind",
    "target": "break"
  }
]
```
Your game engine needs to handle these keywords appropriately.

## functions Field

`functions` is an array containing all function declarations.

### Function Structure

```json
{
  "name": "play_sound",
  "params": [
    {
      "name": "file",
      "type": "String"
    }
  ],
  "return_type": null
}
```

### Function with Return Value

```json
{
  "name": "get_player_name",
  "params": [],
  "return_type": "String"
}
```

### Function with Multiple Parameters

```json
{
  "name": "spawn_enemy",
  "params": [
    {
      "name": "enemy_type",
      "type": "String"
    },
    {
      "name": "x",
      "type": "Number"
    },
    {
      "name": "y",
      "type": "Number"
    }
  ],
  "return_type": null
}
```

## metadata Field

The `metadata` object contains information about the compilation process.

```json
{
  "metadata": {
    "version": "0.3.0",
    "compiler": "mortar_cli",
    "compiled_at": "2024-01-15T10:30:00Z"
  }
}
```

- `version` (String): The version of the Mortar compiler used.
- `compiler` (String): The name of the compiler tool (e.g., `mortar_cli`).
- `compiled_at` (String): An ISO 8601 timestamp of when the file was compiled (optional).

This data can be useful for debugging, version tracking, and ensuring compatibility.

```json
{
  "nodes": {
    "StartScene": {
      "texts": [
        {
          "content": "Hello!",
          "interpolated": false,
          "events": [
            {
              "index": 0,
              "function": "play_sound",
              "args": ["greeting.wav"]
            }
          ]
        },
        {
          "content": "Are you {get_name()}?",
          "interpolated": true,
          "events": []
        }
      ],
      "choices": [
        {
          "text": "Yes",
          "target": "Confirm"
        },
        {
          "text": "No",
          "target": "Deny"
        }
      ]
    },
    "Confirm": {
      "texts": [
        {
          "content": "Nice to meet you!",
          "interpolated": false,
          "events": []
        }
      ]
    },
    "Deny": {
      "texts": [
        {
          "content": "Oh, sorry!",
          "interpolated": false,
          "events": []
        }
      ]
    }
  },
  "functions": [
    {
      "name": "play_sound",
      "params": [
        {
          "name": "file",
          "type": "String"
        }
      ],
      "return_type": null
    },
    {
      "name": "get_name",
      "params": [],
      "return_type": "String"
    }
  ]
}
```

## Parsing Recommendations

To make parsing easier and safer, it's highly recommended to use data classes or type definitions in your game's programming language.

### TypeScript Type Definitions

```typescript
interface MortarDialogue {
  nodes: Record<string, Node>;
  functions: FunctionDecl[];
  metadata: Metadata;
}

interface Node {
  texts: TextBlock[];
  choices?: Choice[];
  next_node?: string;
}

interface TextBlock {
  content: string;
  interpolated: boolean;
  events: EventGroup[];
}

interface EventGroup {
  index: number;
  calls: FunctionCall[];
}

interface FunctionCall {
  function: string;
  args: any[];
}

interface Choice {
  text: string;
  target?: string;
  nested?: Choice[];
  condition?: string;
}

interface FunctionDecl {
  name: string;
  params: Param[];
  return_type: string | null;
}

interface Param {
  name: string;
  type: string;
}

interface Metadata {
  version: string;
  compiler: string;
  compiled_at?: string;
}
```

### Python Dataclasses

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Any

@dataclass
class FunctionCall:
    function: str
    args: List[Any]

@dataclass
class EventGroup:
    index: float
    calls: List[FunctionCall]

@dataclass
class TextBlock:
    content: str
    interpolated: bool
    events: List[EventGroup]

@dataclass
class Choice:
    text: str
    target: Optional[str] = None
    nested: Optional[List['Choice']] = None
    condition: Optional[str] = None

@dataclass
class Node:
    texts: List[TextBlock]
    choices: Optional[List[Choice]] = None
    next_node: Optional[str] = None

@dataclass
class Param:
    name: str
    type: str

@dataclass
class FunctionDecl:
    name: str
    params: List[Param]
    return_type: Optional[str]

@dataclass
class Metadata:
    version: str
    compiler: str
    compiled_at: Optional[str] = None

@dataclass
class MortarDialogue:
    nodes: Dict[str, Node]
    functions: List[FunctionDecl]
    metadata: Metadata
```

## Important Notes

### 1. Character Encoding
JSON files are always encoded in **UTF-8**. Ensure your file reading process uses the correct encoding to avoid garbled text.

### 2. Node Order
The `nodes` field is a dictionary (object), which means **the order of nodes is not guaranteed**. Your logic should not rely on the order in which nodes appear in the JSON file. Always use node names to access them.

### 3. Empty Arrays vs. Null
- If a text block has no events, its `events` field will be an empty array `[]`.
- If a node has no choices, the `choices` field might be `null` or absent entirely. Your parser should handle both cases.

### 4. Interpolation Handling
For text blocks where `interpolated` is `true`, your game engine needs to perform the replacement.
```javascript
if (textBlock.interpolated) {
  let result = textBlock.content;
  // Find and replace all {function_name()} placeholders
  result = result.replace(/\{(\w+)\(\)\}/g, (_, funcName) => {
    return callYourGameFunction(funcName);
  });
  displayText(result);
}
```

### 5. Conditional Choices
For choices with a `condition` field, your engine must call the specified function and check the boolean result.
```python
for choice in node['choices']:
    if 'condition' in choice:
        if not call_your_game_function(choice['condition']):
            continue  # Do not display this choice
    show_choice(choice['text'])
```


## Next Steps

- See a full integration example: [Integrating with Your Game](../5_3_game-integration.md)
- Find answers to common questions: [FAQ](./7_2_faq.md)
- Learn how to contribute: [Contributing Guide](./7_3_contributing.md)
