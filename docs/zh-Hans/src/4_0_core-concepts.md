# 理解 Mortar 语言

学会了基础操作，现在让我们深入了解 Mortar 的核心思想。

## Mortar 的三个关键组成

写一个 Mortar 脚本，主要就是在处理这几样东西：

### 1. 节点（Nodes）
想象节点就像是对话中的 "场景" 或 "片段"。每个节点可以包含：
- 若干段文本
- 对应的事件
- 玩家的选择
- 下一个节点

### 2. 文本与事件（Text & Events）
这是 Mortar 最核心的特色：
- **文本**：纯粹的对话内容，不掺杂任何 富文本 / 技术标记
- **事件**：在特定字符位置触发的动作（音效、动画等）
- 它们分开写，但通过索引关联起来。

### 3. 选择（Choices）
让玩家参与进来的关键：
- 列出若干选项
- 每个选项可以跳转到不同节点
- 可以设置条件（比如必须有某个道具才显示）

## Mortar 的设计哲学

### 分离关注点

传统的对话系统可能长这样：
```
"你好<sound=greeting.wav>，欢迎<anim=wave>来到这里！"
```

看起来很乱对吧？写手要记住各种标记，程序员也很难维护。

Mortar 的方式：
```mortar
text: "你好，欢迎来到这里！"
with events: [
    0, play_sound("greeting.wav")
    3, show_animation("wave")
]
```

文本就是文本，事件就是事件。清清楚楚！

### 位置即时间

Mortar 用"字符位置"来控制事件发生的时机：

```mortar
text: "你好世界！"
with events: [
    0, sound_a()  // 在"你"字时触发
    2, sound_b()  // 在"世"字时触发
    4, sound_c()  // 在"！"时触发
]
```

这个位置可以是：
- **整数**：适合打字机效果（一个字一个字显示）
- **小数**：适合语音同步（比如在某句话说到 2.5 秒时）

### 声明式语法

你只需要描述"做什么"，不用管"怎么做"：

```mortar
choice: [
    "选项A" -> 节点A,
    "选项B" when has_key() -> 节点B
]
```
`has_key()` 的代码实现完全由程序方实现。

## 数据流：从 Mortar 到游戏

让我们看看完整的流程：

```
写 Mortar    你用 Mortar 语言写对话
   │
   ▼
编译成 JSON    mortar 命令把它编译成 JSON
   │
   ▼
游戏读取并执行    你的游戏引擎读取 JSON 并按照指示执行
```

## 各部分详细说明

想深入了解每个部分？

- [节点：对话的积木块](./4_1_nodes.md) - 节点的所有用法
- [文本与事件：分离的艺术](./4_2_text-events.md) - 如何优雅地关联文本和事件
- [选项：让玩家做选择](./4_3_choices.md) - 创建分支对话
- [函数：连接游戏世界](./4_4_functions.md) - 声明和使用函数
- [变量与常量](./4_5_variables.md) - 管理对话状态与公共文案
- [分支插值](./4_6_branch-interpolation.md) - 提供 Fluent 风格的局部差异
- [本地化策略](./4_7_localization.md) - 组织多语言脚本与文档
- [节点中的控制流](./4_8_control-flow.md) - 使用 `if/else` 控制文本
- [事件系统与时间线](./4_9_event-system.md) - 复用命名事件与演出
- [枚举与结构化状态](./4_10_enums.md) - 建模有限状态并驱动分支

## 小提示

- **从简单开始**：先写纯文本对话，再慢慢加事件和选项
- **善用注释**：用 `//` 给自己留笔记
- **合理命名**："NodeName"、函数名要见名知意
- **保持干净**：Mortar 的优势就是干净，别把逻辑写得太复杂

准备好深入了解了吗？从[节点](./4_1_nodes.md)开始吧！
