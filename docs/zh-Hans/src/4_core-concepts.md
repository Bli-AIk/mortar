# 理解 Mortar 语言

学会了基础操作，现在让我们深入了解 Mortar 的核心思想。

## Mortar 的三个关键组成

写一个 Mortar 脚本，主要就是在处理这三样东西：

### 1. 节点（Nodes）
想象节点就像是对话中的"场景"或"片段"。每个节点可以包含：
- 若干段文本
- 对应的事件
- 玩家的选择
- 跳转到下一个节点的指示

**比喻**：就像一本书的章节，或者电影的场景。

### 2. 文本与事件（Text & Events）
这是 Mortar 最核心的特色：
- **文本**：纯粹的对话内容，不掺杂任何技术标记
- **事件**：在特定字符位置触发的动作（音效、动画等）
- 它们分开写，但通过位置索引关联起来

**比喻**：就像电影剧本（文本）和导演标注（事件）分开，但知道在哪一句话时做什么动作。

### 3. 选择（Choices）
让玩家参与进来的关键：
- 列出若干选项
- 每个选项可以跳转到不同节点
- 可以设置条件（比如必须有某个道具才显示）

**比喻**：就像"选择你自己的冒险"类图书。

## Mortar 的设计哲学

### 分离关注点

传统的对话系统可能长这样：
```
"你好<sound=greeting.wav>，欢迎<anim=wave>来到这里！"
```

看起来很乱对吧？写手要记住各种标记，程序员也很难维护。

Mortar 的方式：
```mortar
text: "你好，欢迎来到这里！"
events: [
    0, play_sound("greeting.wav")
    3, show_animation("wave")
]
```

文本就是文本，事件就是事件。清清楚楚！

### 位置即时间

Mortar 用"字符位置"来控制事件发生的时机：

```mortar
text: "你好世界！"
events: [
    0, sound_a()  // 在"你"字时触发
    2, sound_b()  // 在"世"字时触发
    4, sound_c()  // 在"！"时触发
]
```

这个位置可以是：
- **整数**：适合打字机效果（一个字一个字显示）
- **小数**：适合语音同步（比如在某句话说到 2.5 秒时）

### 声明式语法

你只需要描述"要什么"，不用管"怎么做"：

```mortar
choice: [
    "选项A" -> 节点A,
    "选项B" when has_key() -> 节点B
]
```

你说"我要这些选项"，Mortar 编译器会帮你处理成游戏能理解的格式。

## 数据流：从 Mortar 到游戏

让我们看看完整的流程：

```
┌─────────────┐
│  写 Mortar  │  你用 Mortar 语言写对话
│   脚本      │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  编译成     │  mortar 命令把它编译成 JSON
│   JSON      │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  游戏读取   │  你的游戏引擎读取 JSON
│   并执行    │  并按照指示执行
└─────────────┘
```

## 各部分详细说明

想深入了解每个部分？

- [节点：对话的积木块](./4_1_nodes.md) - 节点的所有用法
- [文本与事件：分离的艺术](./4_2_text-events.md) - 如何优雅地关联文本和事件
- [选项：让玩家做选择](./4_3_choices.md) - 创建分支对话
- [函数：连接游戏世界](./4_4_functions.md) - 声明和使用函数

## 小提示

- **从简单开始**：先写纯文本对话，再慢慢加事件和选项
- **善用注释**：用 `//` 给自己留笔记
- **合理命名**："NodeName"、函数名要见名知意
- **保持干净**：Mortar 的优势就是干净，别把逻辑写得太复杂

准备好深入了解了吗？从[节点](./4_1_nodes.md)开始吧！
